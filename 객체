객체의 특성

 

1. 상속성 - 구성요소(멤버필드, 메서드)를 물려줌.

- 계층적으로 상,하위가 존재함. 부모클래스는 슈퍼클래스, 베이스클래스 자식클래스는 서브클래스, 파생클래스라고 부른다.

- 범위를 확장이 가능하다. 상속받은 클래스의 범위 외에도 더 확장해서 사용할 수 있다.

- 자식클래스 이름 옆, 괄호 전에 extends 부모클래스 이름을 설정하면 상속이 가능하다. ex)class aaa extends object {}

- 부모클래스에서 상속하지 않을 요소는 앞에 private를 붙여주면 된다. private가 붙으면 상속을 해줘도 자식클래스에서는 사용 할 수가 없다.

1) 접근 제한에 대하여

- 따로 앞에 붙이지 않으면 같은 패키지 안에서만 접근이 가능하게 package로 설정된다.

- 상속에 관련된 패키지를 기본 상태에서 다른 패키지로 옮기면 상속이 불가능 하게 되어 빨간줄과 함께 not visible이라고 확인할 수 있다.

- 패키지가 다를때 접근을 할 수 있게 하고 싶다면 멤버필드 앞에 public을 붙여야 한다.

- protected는 패키지+상속의 범위까지 적용된다. 이 경우 같은 패키지가 아니어도 상속이 되어있는 클래스면 가능하다.

- 접근의 범위 

private: 클래스 내부에서만 허용

^

package: (명시하지 않은 표현) package 범위에서만 접근 허용

^

protected: package + 상속관계 접근 허용

^

public: 어디서든 접근허용

순으로 넓어진다.

- 많이 쓰이는 타입은 public, private 이다.

- 설정하는 이유는 실수를 방지하기 위한 이유도 있지만 데이터 보안때문이다.

- 슈퍼클래스의 요소를 지정해줄 때에는 this. 으로도 접근이 가능하지만 좀 더 명확하게 하기 위해서 super. 으로 해주는 것이 좋다.

- 자식클래스에서는 슈퍼클래스와 같은 이름으로 멤버필드 설정이 가능기 때문이다. 보편적으로 같은 이름으로 하지 않기는 하지만 혹시 모르니까 확실한 지칭으로 해주는 것이좋다.

- 자식클래스는 활성화 되면 앞에 생략이 되어있기는 하지만 괄호 안에 슈퍼생성자가 먼저 실행되게 적용되어 있다.

ex) public subclass(){

     super();

     } 

- 기본생성자가 없는 슈퍼글래스를 상속할때는 문제가 생긴다. 상속을 할 경우에는 슈퍼클래스에 있는 생성자와 똑같은 형식으로 서브클래스에 형성을 해줘야 상속이 가능하다.

  자식생서자에서 슈퍼생성자를 명시하지 않으면 기본적으로 super();(슈퍼의 기본생성자)로 적용된다.

-슈퍼클래스에도 명시되지 않은 슈퍼클래스가 적용되어 있다. 모든클래스의 몇단계를 거치더라도 슈퍼클래스는 java.lang.Object로 되어있다. Object클래스는 최상위 클래스로 지정되어 있다. 이것은 클래스 생성시에 확인이 가능하다.

- 상속의 관계는 IS-A 관계에 포함된다.

ex) class Animal{}

class Mammal extends Animal{}

//포유동물을 동물입니다. Mammal is a Animal

class Reptile extends Animal{}

//파충류를 동물입니다. Reptile is a Animal

class Dog extends Mammal{}

//개는 포유동물입니다. Dog is a Mammal

//고로 개는 동물입니다.

class Cat extends Mammal{}

//IS-A 관계

- IS-A 관계 외에도 밑에 예시와 동일하게 HAS-A관계도 있다.

class Vehicle{}

class Speed{}

class car extends Vehicle {

	Speed speed;

}

//Car is a Vehicle

//Car has a Speed

//자원을 공유할때는 car는 내부에 Speed의 객체를 생성하여 Speed로 접근한다 //HAS-A 관계

 

class Vehicle{}

class Speed{

	public void println(String str) {

		System.out.println(str);

	}

}

class Car extends Vehicle {

	static Speed speed=new Speed();

}

//Car is a Vehicle

//Car has a Speed

//자원을 공유할때는 car는 내부에 Speed의 객체를 생성하여 Speed로 접근한다 //HAS-A 관계

public class MainTest03 {

	public static void main(String[] args) {

	Car.speed.println("출력내용");

	System.out.println("출력");

	}

}

- 자바는 하나의 자식클래스가 동시에 두개의 슈퍼클래스를 두는 정의를 할 수 없다.  클래스 대 클래스의 관계에서 단일 상속만 지원한다. ex) class AAA extends BBB, CCC (x)

- 슈퍼클래스 -> 서브클래스

1. 슈퍼클래스 -> 서브클래스 (o)

2. 슈퍼클래스 -> 서브클래스(슈퍼클래스) -> 서브클래스 (o)

3. 슈퍼클래스 -> 서브클래스1, 서브클래스2 (o)

 

 

2. 다형성 - 타입이 여러개 존재한다.

- 타입이 여러개 존재할 수 있다.

ex) 1) Sub01 sub01=new Sub01(); //서브의 권한으로 서브메모리에 접근을 한다.

     2) Super01 super01=new Sub01(); //슈퍼클라스의 권한으로 서브메모리에 접근한다.

두가지의 경우 같은 공간에 새로운 걸 만들었지만 정의된 공간이 다른데 1번에 경우 자식클래스에 정의되었고 2번의 경우 슈퍼클래스에 정의가 되었다.

두개의 차이점은 접근범위인데 1번의 경우 자식클래스이기 때문에 접근범위가 자식클래스+부모클래스로 접근이 가능하고

2번의 경우에는 부모클래스이기 때문에 접근범위가 부모클래스로만 제한된다.

- override는 덮어쓰기를 말하는 건가.. 같은 이름의 메서드는 불가하지만 override를 할 경우 기존의 것을 삭제하지는 않지만 덮어쓰는 방식(수정하는 방식)으로 생성이 가능하다. 

  따라서 슈퍼키워드로 접근을 하더라도 오버라이딩한 값(수정된 값)이 보일 수 있다.

-override는 서브클래스에서 적용할 메서드 윗줄에 @override로 적어준다.

 

3. 추상화 - 상속을 하다보면 불편하고 불필요한 요소들이 있을 수 있는데 이를 제거한다. cf) override, 추상메서드, 추상클래스, 인터페이스(interface)

- 추상클래스: 미완성의 클래스 형태. 이건 메모리에 객체로 만들 수가 없다. 이걸 객체로 만들려면 override를 해야한다.
다형성의 경우 메서드를 상속 받은 자식 클래스가 같은 메서드를 오버라이드 해버리면 부모클래스의 메서드를 사용할 일이 없기 때문에 바디를 없애버린다. 그러면 완전한 메서드가 아니기 때문에 오류가 나는데 이런 미완성코드를 인정받기 위해 클래스 앞에 abstract를 붙이면 추상화가 완성된다.

하지만 완성되지 않은 메서드를 가지고 있는 클래스는 오류가 나는데 이또한 완성되지 않은 클래스를 인정받기 위해서 클래스 앞에도 abstract를 붙이면 상속을 통해서 자식클래스에서 바디를 완성해서 완성된 코드를 생성할 수 있다.

이걸 기재를 해주면 자바가 문법적인 오류는 내지 않는 걸로 된다.

미완성 클래스는 객체 생성이 불가능하다.

추상클래스는 추상메서드를 포함한다.

기존의 클래스에서 허용하는 걸 모두 허용하고 추가적으로 추상메서드도 가능하다.

추상 메서드가 포함 되어있지 않아도 추상클래스는 단독으로 객체를 생성 할 수 없다.

단,  알려지지 않은 내부클래스 생성가능

추상클래스 안에서 static 을 붙인 값은 다른 클래스에서 직접 접근이 가능하다.

추상화는 생성자, 필드, 메서드 만들 수는 있으나 접근을 못해서 의미가 없음. 그나마 추상메서드는 사용할 거 같음.

내부에 인스턴스 변수 선언은 가능하다. 의미가 있을 수도 있지만 독립적으로 봤을때는 인스턴스화 할 수가 없는데 의미가 있을까? 하지만 상속받은 곳에서 초기화한다면 의미가 있다.

보통 이런 경우는 변경되는 값은 아니고 고정된 값을 쓰기 위해서 많이 쓴다. 이런경우에는

ex) final static String COLOR="검정" 

이렇게 상수는 대문자로 표기한다. 이런 final이 붙은 경우에는 상속을 받은 클래스에서는 수정이 불가하다. 수정을 시도할 경우 오류가 난다. final은 최종값이라는 뜻.

이런 경우에는 값을 입력하지 않을 경우에는 오류가 나고 초기화를 꼭 해야 한다. 값이 있어야 한다는 뜻.

final의 경우 클래스, 메서드 모두 붙을 수 있지만 재정의가 되지 않음.

이렇게 추상화가 된 경우에 정의는 가능하고 생성자가 있고 명시도 가능하지만 객체화하는 것처럼 문장은 기재할 수 있으나 슈퍼클래스 자체로는 인스턴스화를 할 수 없다. 이러면 슈퍼클래스 단독으로는 할 수 있는게 없고 자식클래스를 통해서 재정의를 해야만 완성이 될 수 있다.

추상메서드: 바디{}가 없는 메서드

추상클래스를 상속받으면 추상클래스 안에 있는 메서드는 다 구현을 해야 자식클래스가 추상클래스가 되는 것을 피할 수 있다.

추상클래스는 뒤에 바디가 없기때문에 {}중괄호가 아닌 ;세미콜론으로 끝을 맺으면 된다.

 

4. 캡슐화 - 멤버필드를 외부로부터 접근을 막아버림. ex)필드를 private로 만 접근을 할 수 있게 하고 public 메서드를 만들어서 그걸 통해서 접근하게 만듦.

- 굳이 이렇게 번거롭게 하는 이유는 데이터를 조금이라도 더 안전하게 보관하기 위해서

 

 

생성자는 명시되어있지 않으나 어떤 타입으로라도 명시를 하면 기본 생성자는 없어지게 된다.

기본 생성자를 명시하고 추가로 다른 생성자를 생성하면 추가가 되는 것이다.
