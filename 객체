객체의 특성

 

1. 상속성 - 구성요소(멤버필드, 메서드)를 물려줌.

- 계층적으로 상,하위가 존재함. 부모클래스는 슈퍼클래스, 베이스클래스 자식클래스는 서브클래스, 파생클래스라고 부른다.

- 범위를 확장이 가능하다. 상속받은 클래스의 범위 외에도 더 확장해서 사용할 수 있다.

- 자식클래스 이름 옆, 괄호 전에 extends 부모클래스 이름을 설정하면 상속이 가능하다. ex)class aaa extends object {}

- 부모클래스에서 상속하지 않을 요소는 앞에 private를 붙여주면 된다. private가 붙으면 상속을 해줘도 자식클래스에서는 사용 할 수가 없다.

1) 접근 제한에 대하여

- 따로 앞에 붙이지 않으면 같은 패키지 안에서만 접근이 가능하게 package로 설정된다.

- 상속에 관련된 패키지를 기본 상태에서 다른 패키지로 옮기면 상속이 불가능 하게 되어 빨간줄과 함께 not visible이라고 확인할 수 있다.

- 패키지가 다를때 접근을 할 수 있게 하고 싶다면 멤버필드 앞에 public을 붙여야 한다.

- protected는 패키지+상속의 범위까지 적용된다. 이 경우 같은 패키지가 아니어도 상속이 되어있는 클래스면 가능하다.

- 접근의 범위 

private: 클래스 내부에서만 허용

^

package: (명시하지 않은 표현) package 범위에서만 접근 허용

^

protected: package + 상속관계 접근 허용

^

public: 어디서든 접근허용

순으로 넓어진다.

- 많이 쓰이는 타입은 public, private 이다.

- 설정하는 이유는 실수를 방지하기 위한 이유도 있지만 데이터 보안때문이다.

- 슈퍼클래스의 요소를 지정해줄 때에는 this. 으로도 접근이 가능하지만 좀 더 명확하게 하기 위해서 super. 으로 해주는 것이 좋다.

- 자식클래스에서는 슈퍼클래스와 같은 이름으로 멤버필드 설정이 가능기 때문이다. 보편적으로 같은 이름으로 하지 않기는 하지만 혹시 모르니까 확실한 지칭으로 해주는 것이좋다.

- 자식클래스는 활성화 되면 앞에 생략이 되어있기는 하지만 괄호 안에 슈퍼생성자가 먼저 실행되게 적용되어 있다.

ex) public subclass(){

     super();

     } 

- 기본생성자가 없는 슈퍼글래스를 상속할때는 문제가 생긴다. 상속을 할 경우에는 슈퍼클래스에 있는 생성자와 똑같은 형식으로 서브클래스에 형성을 해줘야 상속이 가능하다.

  자식생서자에서 슈퍼생성자를 명시하지 않으면 기본적으로 super();(슈퍼의 기본생성자)로 적용된다.

-슈퍼클래스에도 명시되지 않은 슈퍼클래스가 적용되어 있다. 모든클래스의 몇단계를 거치더라도 슈퍼클래스는 java.lang.Object로 되어있다. Object클래스는 최상위 클래스로 지정되어 있다. 이것은 클래스 생성시에 확인이 가능하다.

- 상속의 관계는 IS-A 관계에 포함된다.

ex) class Animal{}

class Mammal extends Animal{}

//포유동물을 동물입니다. Mammal is a Animal

class Reptile extends Animal{}

//파충류를 동물입니다. Reptile is a Animal

class Dog extends Mammal{}

//개는 포유동물입니다. Dog is a Mammal

//고로 개는 동물입니다.

class Cat extends Mammal{}

//IS-A 관계

- IS-A 관계 외에도 밑에 예시와 동일하게 HAS-A관계도 있다.

class Vehicle{}

class Speed{}

class car extends Vehicle {

	Speed speed;

}

//Car is a Vehicle

//Car has a Speed

//자원을 공유할때는 car는 내부에 Speed의 객체를 생성하여 Speed로 접근한다 //HAS-A 관계

 

class Vehicle{}

class Speed{

	public void println(String str) {

		System.out.println(str);

	}

}

class Car extends Vehicle {

	static Speed speed=new Speed();

}

//Car is a Vehicle

//Car has a Speed

//자원을 공유할때는 car는 내부에 Speed의 객체를 생성하여 Speed로 접근한다 //HAS-A 관계

public class MainTest03 {

	public static void main(String[] args) {

	Car.speed.println("출력내용");

	System.out.println("출력");

	}

}

- 자바는 하나의 자식클래스가 동시에 두개의 슈퍼클래스를 두는 정의를 할 수 없다.  클래스 대 클래스의 관계에서 단일 상속만 지원한다. ex) class AAA extends BBB, CCC (x)

- 슈퍼클래스 -> 서브클래스

1. 슈퍼클래스 -> 서브클래스 (o)

2. 슈퍼클래스 -> 서브클래스(슈퍼클래스) -> 서브클래스 (o)

3. 슈퍼클래스 -> 서브클래스1, 서브클래스2 (o)

 

 

2. 다형성 - 타입이 여러개 존재한다.

- 타입이 여러개 존재할 수 있다.

ex) 1) Sub01 sub01=new Sub01(); //서브의 권한으로 서브메모리에 접근을 한다.

     2) Super01 super01=new Sub01(); //슈퍼클라스의 권한으로 서브메모리에 접근한다.

두가지의 경우 같은 공간에 새로운 걸 만들었지만 정의된 공간이 다른데 1번에 경우 자식클래스에 정의되었고 2번의 경우 슈퍼클래스에 정의가 되었다.

두개의 차이점은 접근범위인데 1번의 경우 자식클래스이기 때문에 접근범위가 자식클래스+부모클래스로 접근이 가능하고

2번의 경우에는 부모클래스이기 때문에 접근범위가 부모클래스로만 제한된다.

- override는 덮어쓰기를 말하는 건가.. 같은 이름의 메서드는 불가하지만 override를 할 경우 기존의 것을 삭제하지는 않지만 덮어쓰는 방식(수정하는 방식)으로 생성이 가능하다. 

  따라서 슈퍼키워드로 접근을 하더라도 오버라이딩한 값(수정된 값)이 보일 수 있다.

-override는 서브클래스에서 적용할 메서드 윗줄에 @override로 적어준다.

 

3. 추상화 - 상속을 하다보면 불편하고 불필요한 요소들이 있을 수 있는데 이를 제거한다. cf) override, 추상메서드, 추상클래스, 인터페이스(interface)

- 추상클래스: 미완성의 클래스 형태. 이건 메모리에 객체로 만들 수가 없다. 이걸 객체로 만들려면 override를 해야한다.

 

4. 캡슐화 - 멤버필드를 외부로부터 접근을 막아버림. ex)필드를 private로 만 접근을 할 수 있게 하고 public 메서드를 만들어서 그걸 통해서 접근하게 만듦.

- 굳이 이렇게 번거롭게 하는 이유는 데이터를 조금이라도 더 안전하게 보관하기 위해서

 

 

생성자는 명시되어있지 않으나 어떤 타입으로라도 명시를 하면 기본 생성자는 없어지게 된다.

기본 생성자를 명시하고 추가로 다른 생성자를 생성하면 추가가 되는 것이다.
